# How it works

## Marching Cubes

The Marching Cubes algorithm creates an isosurface from a function mapping 3D space to a scalar value.
To create the isosurface, the function is sampled at discrete points in a cubic lattice.
Each point is classified as 'inside' or 'outside' depending on its value.

To create the surface, the points are considered in neighbouring groups of 2 x 2 x 2, forming a cube
between each group of 8 points. 
The classifications of the 8 corners are used to create an 8-bit number, the 'cube case' for each cube.

Cases 0 and 255 produce no geometry as they are fully inside or outside the surface.
All other cases intersect the surface so they will contain geometry.

In Marching Cubes, the vertices are placed along each cube edge with different signs at its endpoints.
The generated polygons are placed in the interior of the cube linking these vertices.
The exact configuration for each cube is given by using the cube case as an index into a lookup table.

For an in depth explanation see http://http://paulbourke.net/geometry/polygonise/

Some implementations create new vertices for the polygons in each cube. However, since the lattice edges 
are shared among 4 cubes, it's only necessary to create new vertices on the leading X, Y and Z axes of 
each cube, the vertices on the other edges will be generated by the previous cubes in each direction.
To do this requires storing information about the IDs of vertices found into a 3D buffer, so that they can
be located when each cube is adding its polygon information to the element buffer, since each cube's triangles 
may now contain vertices generated by other cubes. 

## Dual Marching Cubes

Dual Marching Cubes is a variation on Marching Cubes which generates the dual mesh. 
The vertices are placed in the interior of each cube cell rather than on the edges, and the polygons lie
around the cube edges.
Each connected polygon in a cube interior in Marching Cubes (which may have more than 3 sides) is replaced
with a vertex, and each vertex along a cube edge is replaced by a quad surrounding the edge, linking vertices 
in the 4 cubes that share the edge.
The cube cases are generated exactly as in Marching Cubes, and a different set of lookup tables are used to
generate the geometry.

## Histogram Pyramids

Histogram Pyramids are a useful way to perform a parallel count of spatial data on GPU, and assign a unique ID 
to each data point.

A histogram pyramid is a stack of integer-valued textures with power-of-two sizes, each layer half the size 
of the one below in each dimension. In this application, the histopyramids are 3D, so each entry in a layer 
corresponds to a 2 x 2 x 2 block in the layer below. 

To build a pyramid, begin with a 3D grid of integer data. Each group of 8 cells is summed by a shader invocation 
and written into a single cell in the layer above. This continues for each layer until the final layer has size 1, 
and contains the total sum of all the entries.

Given this total, we can find a location in the base layer for the Nth data point in the given range by traversing 
the pyramid from the top down. 

Starting from the second-from-top layer, sum the cells in order:

0,0,0   1,0,0   0,1,0   1,1,0,   0,0,1,   1,0,1   0,1,1   1,1,1     

and stop when (sum > N). Then descend to the next layer at the 2 x 2 x 2 block corresponding to the current cell,
carry over the sum of all previous cells, and repeat. 
Once the base layer is reached, the cell found will be the one containing element N.

## Marching Cubes Implementation

### Building the histogram pyramids
Each cube case describes the geometry that will be generated inside that cube. Since vertices are shared across cube 
boundaries, two pieces of information are needed for each cube – the number of triangles, and the number of new vertices 
(these will only be created on leading edges). These values are found in lookup tables, indexed by cube case. 
Since there are two values to count, two histogram pyramids are built. The base layers have size (resolution/2)^3 and are 
created by summing the results of the table lookups in 2 x 2 x 2 blocks. Full-res base layers are not built to save space, 
since the full-res information can be deduced from the cube case texture.

### Finding vertices
To create an ordered list of vertices, the vertex number pyramid is traversed as described above, using a number of shader 
invocations equal to the total number of vertices found. The final layer is the cube case texture, so a table lookup is done 
to find the number of vertices per cube in this layer, until the final cube is found.

Each cube may create up to 3 vertices, so each shader invocation subtracts the sum of all previous cubes from its ID to find 
its index within its cube. 
If it is the first vertex within a cube, it writes its ID number into the full-res 3D texture originally used to hold sample 
values, at the cube’s position. This will be used later when indexing the triangles. 

It then uses the cube case and its index within the cube to look up if it is on the leading X, Y or Z edge of the cube. 
The distance field is then sampled again at the two endpoints of the edge, and the vertex position is interpolated between
the two points according to each point's absolute distance value.

To calculate the normals, central differences are used. The distance field is sampled 6 times around the final position, at a small
offset in each direction along each axis. The differences between the values are used to calculate the 3 components of the normal, 
which is then normalized.

### Finding triangles
A shader invocation per-triangle is dispatched, and descends the triangles pyramid to find its cube and offset from the first
vertex in the cube in an identical manner to the vertices pyramid. Each invocation then reads 3 entries from a lookup table using 
the cube case and offset to find its 3 vertices. 

Since vertices lie on cube edges, each cube’s triangles can contain vertices from previous cubes along any of the 3 axes. 
The triangle lookup table uses a bitfield format for each vertex, representing whether a vertex is on an X, Y or Z edge, 
and whether it belongs to the current cube or a neighbour. The texture generated in the last step, containing the ID of the first
vertex in each cube, is used to calculate the ID of each vertex in the triangle, and these are then written to the element buffer.

## Dual Marching Cubes Implementation

### Building the histogram pyramids
The pyramids are built in the same way as for Marching Cubes, but the pyramid that counted vertices now corresponds to edges/quads, 
and a new lookup table is used to build the second pyramid, which now counts vertices rather than triangles.

### Finding edges
This stage works the same as finding vertices in Marching Cubes with some small modifications. The pyramid is descended and each
edge's approximate intersection with the surface is calculated as described above. This edge position will be used to help 
calculate the position of the four vertices that lie around that edge, and is stored in what will later become the normal buffer.

Each edge will produce 2 triangles, so it gets 6 entries in the element buffer. The last of these entries is now written 
with a marker that determines whether the edge's quad is 'flipped' based on the cube case - that is, does the quad's normal point
towards or away from the cube's leading vertex. This allows the next stage to use a consistent winding order to add vertex indices
to each quad, which can then be reversed if necessary in the final stage.

The first edge within each cube has its id written into the big 3D texture to help with assembling the geometry, as before.

### Finding vertices
This works in a similar manner to finding triangles in Marching Cubes. The second pyramid is descended to find each vertex's cube,
and bitfield markers are read from a lookup table by cube-case to find which edges it is associated with. These markers work similarly
to the triangle markers used for Marching Cubes, with the lowest 5 bits containing offset from the current cube and edge direction.
The 6th and 7th bits contain the vertex's offset within each edge's quad, starting from 0 in the cube that created the edge and 
proceeding clockwise???????

Each edge's ID is calculated by sampling the large 3D texture as before. The edges' positions are read from the normal buffer and 
averaged to get the vertex position, which is written to the vertex buffer. At the same time, the element buffer for each edge is
written with the vertex's ID, using the offset decoded from the bitfield.

### Finding final positions and normals
Now that all vertices' aprroximate positions have been found, the edge position data is no longer needed, so the normal buffer 
can be filled with the real normals. These are calculated with the central differences method just as in Marching Cubes, 
sampled at the vertex position calculated in the last stage. 

For slightly better vertex positioning than just using the centroid method, the distance field is sampled again at the current position,
and the vertex is moved along the calculated normal by this distance to bring it closer to the true surface.

### Finding triangles
Finally the quads are split into triangles. Each quad's 6 entries in the element buffer currently hold its 4 vertices in clockwise
order, nothing, and its 'flipped' status respectively. The positions of the 4 corners are compared, and the shortest diagonal is 
chosen to split along to avoid skinny triangles. The chosen split and winding order are then used to write the 4 vertices into 
the 6 entries in the appropriate order.