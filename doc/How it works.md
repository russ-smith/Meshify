# How it works

## Marching Cubes

The Marching Cubes algorithm creates an isosurface from a function mapping 3D space to a scalar value.
To create the isosurface, the function is sampled at discrete points in a cubic lattice.
Each point is classified as 'inside' or 'outside' depending on its value.

To create the surface, the points are considered in neighbouring groups of 2 x 2 x 2, forming a cube
between each group of 8 points. 
The classifications of the 8 corners are used to create an 8-bit number, the 'cube case' for each cube.

Cases 0 and 255 produce no geometry as they are fully inside or outside the surface.
All other cases intersect the surface so they will contain geometry.

In Marching Cubes, the vertices are placed along each cube edge with different signs at its endpoints.
The generated polygons are placed in the interior of the cube linking these vertices.
The exact configuration for each cube is given by using the cube case as an index into a lookup table.

For an in depth explanation see http://http://paulbourke.net/geometry/polygonise/

Some implementations create new vertices for the polygons in each cube. However, since the lattice edges 
are shared among 4 cubes, it's only necessary to create new vertices on the leading X, Y and Z axes of 
each cube, the vertices on the other edges will be generated by the previous cubes in each direction.
To do this requires storing information about the IDs of vertices found into a 3D buffer, so that they can
be located when each cube is adding its polygon information to the element buffer, since each cube's triangles 
may now contain vertices generated by other cubes. 

## Dual Marching Cubes

Dual Marching Cubes is a variation on Marching Cubes which generates the dual mesh. 
The vertices are places in the interior of each cube cells rather than on the edges, and the polygons lie
around the cube edges.
Each connected polygon in a cube interior in Marching Cubes (which may have more than 3 sides) is replaced
with a vertex, and each vertex along a cube edge is replaced by a quad surrounding the edge, linking vertices 
in the 4 cubes that share the edge.
The cube cases are generated exactly as in Marching Cubes, and a different set of lookup tables are used to
generate the geometry.

## Histogram Pyramids

Histogram Pyramids are a useful way to perform a parallel count of spatialdata on GPU, and assign a unique ID 
to each data point.

A histogram pyramid is a stack of integer-valued textures with power-of-two sizes, each layer half the size 
of the one below in each dimension. In this application, the histopyramids are 3D, so each entry in a layer 
corresponds to a 2 x 2 x 2 block in the layer below. 

To build a pyramid, begin with a 3D grid of integer data. Each group of 8 cells is summed by a shader invocation 
and written into a single cell in the layer above. This continues for each layer until the final layer has size 1, 
and contains the total sum of all the entries.

Given this total, we can find a location in the base layer for the Nth data point in the given range by traversing 
the pyramid from the top down. 

Starting from the second-from-top layer, sum the cells in order:

0,0,0   1,0,0   0,1,0   1,1,0,   0,0,1,   1,0,1   0,1,1   1,1,1     

and stop when (sum > N). Then descend to the next layer at the 2 x 2 x 2 block corresponding to the current cell,
carry over the sum of all previous cells, and repeat. 
Once the base layer is reached, the cell found will be the one containing element N.

## Marching Cubes Implementation

### Building the histogram pyramids
Each cube case describes the geometry that will be generated inside that cube. Since vertices are shared across cube 
boundaries, two pieces of information are needed for each cube – the number of triangles, and the number of new vertices 
(these will only be created on leading edges). These values are found in lookup tables, indexed by cube case. 
Since there are two values to count, two histogram pyramids are built. The base layers have size (resolution/2)^3 and are 
created by summing the results of the table lookups in 2 x 2 x 2 blocks. Full-res base layers are not built to save space, 
since the full-res information can be deduced from the cube case texture.

### Finding vertices
To create an ordered list of vertices, the vertex number pyramid is traversed as described above, using a number of shader 
invocations equal to the total number of vertices found. The final layer is the cube case texture, so a table lookup is done 
to find the number of vertices per cube in this layer, until the final cube is found.

Each cube may create up to 3 vertices, so each shader invocation subtracts the sum of all previous cubes from its ID to find 
its index within its cube. 
If it is the first vertex within a cube, it writes its ID number into the full-res 3D texture originally used to hold sample 
values, at the cube’s position. This will be used later when indexing the triangles. 

It then uses the cube case and its index within the cube to look up if it is on the leading X, Y or Z edge of the cube. 
A simple 32-bit marker is written out to the vertex buffer containing 10 bits each for the cube’s X, Y and Z coordinates, 
and the remaining 2 bits specifying the edge.

### Finding triangles
A shader invocation per-triangle is dispatched, and descends the triangles pyramid to find its cube and offset in an identical 
manner to the vertices pyramid. Each invocation then reads 3 entries from a lookup table using the cube case and offset to find 
its 3 vertices. 

Since vertices lie on cube edges, each cube’s triangles can contain vertices from previous cubes along any of the 3 axes. 
The triangle lookup table uses a bitfield format for each vertex, representing whether a vertex is on an X, Y or Z edge, 
and whether it belongs to the current cube or a neighbour. The texture generated in the last step, containing the ID of the first
vertex in each cube, is used to calculate the ID of each vertex in the triangle, and these are then written to the element buffer.

### Finding vertex positions and normals
Each vertex's final positon is calculated from its marker point. The marker point is decoded to find which cube it is in and which edge it 
lies on. The distance field is then sampled again at the two endpoints of the edge, and the vertex position is interpolated between
the two points according to each point's absolute distance value.

To calculate the normals, central differences are used. The distance field is sampled 6 times around the final position, at a small
offset in each direction along each axis. The differences between the values are used to calculate the 3 components of the normal, 
which is then normalized.
